{
-- Suppresses warning about a redundant import generated by Alex
{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# OPTIONS_GHC -fno-prof-auto #-}

module Blossom.Parsing.Lexer (
    Alex(..),
    runLexer,
    lexError,
    lexer,
    tokenize,
) where

import Blossom.Common.Name (ModuleName, Ident(..))
import Blossom.Common.Source (Position, SourceLoc(..), mkPos)
import Blossom.Parsing.Token (Token(..))
import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy.Char8 as CBS (foldl', unpack)
-- import qualified Data.ByteString.Lazy as ByteString -- imported by Alex
import Data.Char (digitToInt)
import Prettyprinter (Doc, Pretty(..), nest, (<+>))
import qualified Prettyprinter as P (line)

}

%wrapper "monadUserState-bytestring"

$digit              = [0-9]
$small              = [a-z\_]
$big                = [A-Z]
$id_char            = [a-zA-Z0-9\_\']
$symbol             = [\!\#\$\%\&\*\+\.\/\<\=\>\?\@\^\|\-\~]

@comment            = "--"\-*[^$symbol].*
@integer            = $digit+
@float              = $digit+ \. $digit+
@char               = \' \\ [abfnrtv\\\'\"] \'
                    | \' [^\'\\] \'
@string             = \" [^\"]* \"
@small_id           = $small $id_char*
@big_id             = $big $id_char*
@operator           = $symbol $symbol*
@qualifier          = @big_id "::"

tokens :-
    "\\"                    { reserved TokBackslash }
    ";"                     { reserved TokSemi }
    ":"                     { reserved TokColon }
    "->"                    { reserved TokArrow }
    "="                     { reserved TokEquals }
    "=>"                    { reserved TokEqArrow }
    "("                     { reserved TokLParen }
    ")"                     { reserved TokRParen }
    "{"                     { reserved TokLBrace }
    "}"                     { reserved TokRBrace }
    "import"                { reserved TokImport }
    "func"                  { reserved TokFunc }
    "data"                  { reserved TokData }
    "match"                 { reserved TokMatch }
    $white+                 { skip }
    @comment+               { skip }
    @integer                { integer }
    @float                  { float }
    @char                   { char }
    @string                 { string }
    @qualifier* @small_id   { smallId }
    @qualifier* @big_id     { bigId }
    @qualifier* @operator   { operator }


-- strange placement makes error message positions from Alex accurate
{alexEOF :: Alex Token
alexEOF = return TokEnd


-- data AlexState = AlexState {
--         alex_pos :: !AlexPosn,  -- position at current input location
--         alex_inp :: ByteString.ByteString, -- the current input
--         alex_chr :: !Char,      -- the character before the input
--         alex_scd :: !Int        -- the current startcode
--       , alex_ust :: AlexUserState -- AlexUserState will be defined in the user program
--     }

-- type AlexInput = (
--     AlexPosn,                 -- current position,
--     Char,                     -- previous char
--     ByteString.ByteString,    -- current input string
--     Int64                     -- bytes consumed so far
--     )

data AlexUserState = AlexUserState {
    moduleName :: ModuleName,
    filePath :: FilePath
    }

-- AlexUserState initialization function
alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState mempty mempty

setUserState :: AlexUserState -> Alex ()
setUserState us = Alex $ \st -> Right (st{alex_ust=us}, ())

getUserState :: Alex AlexUserState
getUserState = Alex $ \st -> Right (st, alex_ust st)

posnToPos :: AlexPosn -> Position
posnToPos (AlexPn off ln col) = mkPos ln col off

posnToLoc :: AlexPosn -> Alex SourceLoc
posnToLoc posn = do
    let pos = posnToPos posn
    us <- getUserState
    let mdl = moduleName us
        path = filePath us
        loc = SourceLoc path mdl pos pos
    return loc

getSourceLoc :: Alex SourceLoc
getSourceLoc = do
    (posn, _, _, _) <- alexGetInput
    loc <- posnToLoc posn
    return loc

integer :: AlexInput -> Int64 -> Alex Token
integer (_posn, _prev, input, _cons) len = return $ TokInteger $
    CBS.foldl' (\n ch ->
        n * 10 + fromIntegral (digitToInt ch)
        ) 0 (ByteString.take len input)

float :: AlexInput -> Int64 -> Alex Token
float (_posn, _prev, input, _cons) len = return $ TokFloat $
    read (CBS.unpack (ByteString.take len input))

char :: AlexInput -> Int64 -> Alex Token
char (_posn, _prev, input, _cons) len = return $ TokChar
    (read (CBS.unpack $ ByteString.take len input) :: Char)

string :: AlexInput -> Int64 -> Alex Token
string (_posn, _prev, input, _cons) len = return $ TokString $
    -- drop quotation marks
    ByteString.drop 1 (ByteString.take (len - 1) input)

smallId :: AlexInput -> Int64 -> Alex Token
smallId (posn, _prev, input, _cons) len = do
    let iden = ByteString.toStrict $ ByteString.take len input
    loc <- posnToLoc posn
    return $ TokSmallId $ Ident iden loc

bigId :: AlexInput -> Int64 -> Alex Token
bigId (posn, _prev, input, _cons) len = do
    let iden = ByteString.toStrict $ ByteString.take len input
    loc <- posnToLoc posn
    return $ TokBigId $ Ident iden loc

operator :: AlexInput -> Int64 -> Alex Token
operator (posn, _prev, input, _cons) len = do
    let iden = ByteString.toStrict $ ByteString.take len input
    loc <- posnToLoc posn
    return $ TokOperator $ Ident iden loc

reserved :: Token -> AlexInput -> Int64 -> Alex Token
reserved tok (_posn, _prev, _input, _) _len = return tok

lexer :: (Token -> Alex a) -> Alex a
lexer = (alexMonadScan >>=)

-- | Turns a bytestring into either an error message (`@Left@`), or
-- a list of tokens. This should really only be used for testing.
tokenize :: ByteString -> ModuleName -> FilePath -> Either String [Token]
tokenize src mdl path = runLexer src mdl path tokenizer
    where
        tokenizer :: Alex [Token]
        tokenizer = do
            tok <- alexMonadScan
            if tok == TokEnd then
                return []
            else do
                toks <- tokenizer
                return (tok:toks)

runLexer :: ByteString -> ModuleName -> FilePath -> Alex a -> Either String a
runLexer src mdl path alex = runAlex src $
    setUserState (AlexUserState mdl path) >> alex

lexError :: Doc ann -> Alex a
lexError doc = do
    loc <- getSourceLoc
    alexError $ show $
        pretty loc <> pretty ": Error:" <> nest 4 (P.line <> doc)
}
