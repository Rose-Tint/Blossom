{
-- Suppresses warning about a redundant import generated by Alex
{-# OPTIONS_GHC -Wno-unused-imports #-}

module Blossom.Parsing.Lexer (
    Alex(..),
    runAlex,
    alexError,
    alexGetInput,
    lexer,
    tokenize,
    getPrettyAlexPosn,
) where

import Blossom.Parsing.Token (Token(..))
import qualified Data.ByteString.Lazy.Char8 as CBS (foldl', unpack)
-- import qualified Data.ByteString.Lazy as ByteString -- imported by Alex
import Data.Char (digitToInt)

}

%wrapper "monadUserState-bytestring"

$digit              = [0-9]
$small              = [a-z\_]
$big                = [A-Z]
$id_char            = [a-zA-Z0-9\_\']
$symbol             = [\!\#\$\%\&\*\+\.\/\<\=\>\?\@\^\|\-\~]

@comment            = "--"\-*[^$symbol].*
@integer            = $digit+
@float              = $digit+ \. $digit+
@char               = \' \\ [abfnrtv\\\'\"] \'
                    | \' [^\'\\] \'
@string             = \" [^\"]* \"
@small_id           = $small $id_char*
@big_id             = $big $id_char*
@operator           = $symbol $symbol*
@qualifier          = @big_id "::"

tokens :-
    "\\"                    { reserved TokBackslash }
    ";"                     { reserved TokSemi }
    ":"                     { reserved TokColon }
    "->"                    { reserved TokArrow }
    "="                     { reserved TokEquals }
    "=>"                    { reserved TokEqArrow }
    "("                     { reserved TokLParen }
    ")"                     { reserved TokRParen }
    "{"                     { reserved TokLBrace }
    "}"                     { reserved TokRBrace }
    "import"                { reserved TokImport }
    "func"                  { reserved TokFunc }
    "data"                  { reserved TokData }
    "match"                 { reserved TokMatch }
    $white+                 { skip }
    @comment+               { skip }
    @integer                { integer }
    @float                  { float }
    @char                   { char }
    @string                 { string }
    @qualifier* @small_id   { smallId }
    @qualifier* @big_id     { bigId }
    @qualifier* @operator   { operator }


-- strange placement makes error message positions from Alex accurate
{alexEOF :: Alex Token
alexEOF = return TokEnd


-- data AlexState = AlexState {
--         alex_pos :: !AlexPosn,  -- position at current input location
--         alex_inp :: ByteString.ByteString, -- the current input
--         alex_chr :: !Char,      -- the character before the input
--         alex_scd :: !Int        -- the current startcode
--       , alex_ust :: AlexUserState -- AlexUserState will be defined in the user program
--     }

-- type AlexInput = (
--     AlexPosn,                 -- current position,
--     Char,                     -- previous char
--     ByteString.ByteString,    -- current input string
--     Int64                     -- bytes consumed so far
--     )

data AlexUserState = AlexUserState

-- AlexUserState initialization function
alexInitUserState :: AlexUserState
alexInitUserState = AlexUserState


integer :: AlexInput -> Int64 -> Alex Token
integer (_pos, _prev, input, _cons) len = return $ TokInteger $
    CBS.foldl' (\n ch ->
        n * 10 + fromIntegral (digitToInt ch)
        ) 0 (ByteString.take len input)

float :: AlexInput -> Int64 -> Alex Token
float (_pos, _prev, input, _cons) len = return $ TokFloat $
    read (CBS.unpack (ByteString.take len input))

char :: AlexInput -> Int64 -> Alex Token
char (_pos, _prev, input, _cons) len = return $ TokChar
    (read (CBS.unpack $ ByteString.take len input) :: Char)

string :: AlexInput -> Int64 -> Alex Token
string (_pos, _prev, input, _cons) len = return $ TokString $
    -- drop quotation marks
    ByteString.drop 1 (ByteString.take (len - 1) input)

smallId :: AlexInput -> Int64 -> Alex Token
smallId (_pos, _prev, input, _cons) len =
    let name = ByteString.toStrict $ ByteString.take len input
    in return $ TokSmallId $ name

bigId :: AlexInput -> Int64 -> Alex Token
bigId (_pos, _prev, input, _cons) len =
    let name = ByteString.toStrict $ ByteString.take len input
    in return $ TokBigId $ name

operator :: AlexInput -> Int64 -> Alex Token
operator (_pos, _prev, input, _cons) len =
    let name = ByteString.toStrict $ ByteString.take len input
    in return $ TokOperator $ name

reserved :: Token -> AlexInput -> Int64 -> Alex Token
reserved tok (_pos, _prev, _input, _) _len = return tok

lexer :: (Token -> Alex a) -> Alex a
lexer = (alexMonadScan >>=)

-- | Turns a bytestring into either an error message (`@Left@`), or
-- a list of tokens. This should really only be used for testing.
tokenize :: ByteString.ByteString -> Either String [Token]
tokenize bs = runAlex bs tokenizer
    where
        tokenizer :: Alex [Token]
        tokenizer = do
            tok <- alexMonadScan
            if tok == TokEnd then
                return []
            else do
                toks <- tokenizer
                return (tok:toks)

getPrettyAlexPosn :: Alex String
getPrettyAlexPosn = do
    ((AlexPn _off ln col), _, _, _) <- alexGetInput
    return $! "line " ++ show ln ++ ", column " ++ show col

lexError :: Alex a
lexError = do
    posStr <- getPrettyAlexPosn
    alexError $ "Lexical error on " ++ posStr
}
